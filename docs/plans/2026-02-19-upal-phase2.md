# Upal Phase 2: End-to-End Functionality

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Make Upal actually run workflows end-to-end — config loading, execution endpoint, node editing UI, API integration, and real-time event console.

**Architecture:** Extend existing Go backend with config loading (gopkg.in/yaml.v3) and workflow execution endpoint (SSE for streaming events). Extend React frontend with inline node editing, API integration, and execution console.

**Tech Stack:** Go 1.23 / chi / SSE / React 19 / React Flow / Zustand / Tailwind 4

---

### Task 1: Config Loading

**Files:**
- Create: `internal/config/config.go`
- Create: `internal/config/config_test.go`
- Modify: `cmd/upal/main.go`
- Modify: `go.mod` (add `gopkg.in/yaml.v3`)

**What to build:**
A `Config` struct that reads `config.yaml` and returns typed configuration. The server should use config values for port and provider setup.

```go
// internal/config/config.go
package config

type Config struct {
    Server    ServerConfig              `yaml:"server"`
    Database  DatabaseConfig            `yaml:"database"`
    Providers map[string]ProviderConfig `yaml:"providers"`
}

type ServerConfig struct {
    Host string `yaml:"host"`
    Port int    `yaml:"port"`
}

type DatabaseConfig struct {
    URL string `yaml:"url"`
}

type ProviderConfig struct {
    Type   string `yaml:"type"`   // "openai"
    URL    string `yaml:"url"`    // base URL
    APIKey string `yaml:"api_key"`
}

func Load(path string) (*Config, error) // reads yaml file
func LoadDefault() (*Config, error)     // tries config.yaml, then defaults
```

**Test:** Verify Load parses a YAML string correctly. Verify LoadDefault returns defaults when no file exists.

**Wire into main.go:**
```go
func serve() {
    cfg, err := config.LoadDefault()
    // use cfg.Server.Port for addr
    // register providers from cfg.Providers
}
```

**Step 1:** Write test → **Step 2:** Run test, verify fail → **Step 3:** Implement → **Step 4:** Run test, verify pass → **Step 5:** Wire into main.go → **Step 6:** Commit

---

### Task 2: Workflow Run Endpoint with SSE

**Files:**
- Create: `internal/api/run.go`
- Create: `internal/api/run_test.go`
- Modify: `internal/api/server.go` (add runner, provider registry, tool registry fields + route)

**What to build:**
`POST /api/workflows/{name}/run` that:
1. Looks up the workflow by name
2. Accepts JSON body with `inputs` (map of node_id → user input)
3. Creates a Runner, executes the workflow
4. Streams events back via SSE (Server-Sent Events)
5. Returns final session state when done

The Server struct needs to hold a `*engine.Runner`, `*provider.Registry`, and `*tools.Registry` so it can execute workflows.

```go
// Request body
type RunRequest struct {
    Inputs map[string]any `json:"inputs"`
}

// SSE events during execution:
// event: node.started
// data: {"node_id":"agent_1","timestamp":"..."}
//
// event: node.completed
// data: {"node_id":"agent_1","result":"...","timestamp":"..."}
//
// Final response after all events:
// event: done
// data: {"session_id":"...","status":"completed","state":{...}}
```

**Important:** The Server constructor must accept runner + registries:
```go
func NewServer(eventBus *engine.EventBus, sessions *engine.SessionManager,
    runner *engine.Runner, providers *provider.Registry, tools *tools.Registry) *Server
```

Update `cmd/upal/main.go` to pass these.

**Test:** Create a workflow, POST /run with mock executors, verify SSE events stream back.

**Step 1:** Write test → **Step 2:** Implement run handler with SSE → **Step 3:** Update Server struct → **Step 4:** Update main.go → **Step 5:** Run tests → **Step 6:** Commit

---

### Task 3: Node Inline Editing UI

**Files:**
- Create: `web/src/components/editor/nodes/NodeEditor.tsx`
- Modify: `web/src/components/editor/nodes/UpalNode.tsx`
- Modify: `web/src/stores/workflowStore.ts` (add `updateNodeConfig` action)

**What to build:**
When a user clicks on a node, it expands to show editable fields based on node type:

**Input node:**
- Label (text input)
- Placeholder text (text input)

**Agent node:**
- Label (text input)
- Model ID (text input, e.g. "ollama/llama3")
- System Prompt (textarea)
- User Prompt (textarea, supports `{{nodeId}}` template syntax)
- Max Turns (number input)

**Tool node:**
- Label (text input)
- Tool Name (text input)

**Output node:**
- Label (text input)

Add `updateNodeConfig` to the Zustand store:
```typescript
updateNodeConfig: (nodeId: string, config: Record<string, unknown>) => void
updateNodeLabel: (nodeId: string, label: string) => void
```

The UpalNode component should toggle between compact view (current) and expanded editor view on click.

**Step 1:** Add store actions → **Step 2:** Create NodeEditor component → **Step 3:** Integrate into UpalNode → **Step 4:** Verify with `npx tsc -b` → **Step 5:** Commit

---

### Task 4: Frontend API Integration

**Files:**
- Create: `web/src/lib/api.ts`
- Modify: `web/src/App.tsx` (wire Save/Load/Run buttons)
- Modify: `web/src/stores/workflowStore.ts` (add workflow name, run state)

**What to build:**
API client module and wire the header buttons to API calls.

```typescript
// web/src/lib/api.ts
const API_BASE = '/api'

export async function saveWorkflow(wf: WorkflowDefinition): Promise<void>
export async function loadWorkflow(name: string): Promise<WorkflowDefinition>
export async function listWorkflows(): Promise<WorkflowDefinition[]>
export async function runWorkflow(name: string, inputs: Record<string, any>): Promise<EventSource>
```

`runWorkflow` returns an `EventSource` (SSE) that the caller subscribes to for real-time events.

**Store additions:**
```typescript
workflowName: string
setWorkflowName: (name: string) => void
isRunning: boolean
runEvents: Array<{type: string, data: any, timestamp: string}>
addRunEvent: (event: ...) => void
clearRunEvents: () => void
```

**Header buttons:**
- **Save** → serializes workflow, calls `saveWorkflow()`
- **Load** → prompts for name or shows list, calls `loadWorkflow()`, deserializes into canvas
- **Run** → calls `runWorkflow()`, subscribes to SSE events, updates console

**Step 1:** Create api.ts → **Step 2:** Add store fields → **Step 3:** Wire App.tsx buttons → **Step 4:** Verify with `npx tsc -b` → **Step 5:** Commit

---

### Task 5: Execution Console

**Files:**
- Create: `web/src/components/console/Console.tsx`
- Modify: `web/src/App.tsx` (replace footer placeholder)

**What to build:**
Replace the placeholder `<footer>` with a real Console component that:
1. Shows run events in real-time (from store's `runEvents`)
2. Color-codes by event type:
   - `node.started` → blue
   - `node.completed` → green
   - `node.error` → red
   - `model.request` / `model.response` → purple
   - `tool.call` / `tool.result` → orange
3. Auto-scrolls to bottom as new events arrive
4. Shows "Ready" when not running, "Running..." during execution
5. Has a "Clear" button

```tsx
export function Console() {
  const { runEvents, isRunning, clearRunEvents } = useWorkflowStore()
  // render events list with auto-scroll
}
```

**Step 1:** Create Console component → **Step 2:** Wire into App.tsx → **Step 3:** Verify with `npx tsc -b` → **Step 4:** Commit

---

### Task 6: Input Dialog for Run

**Files:**
- Create: `web/src/components/dialogs/RunDialog.tsx`
- Modify: `web/src/App.tsx` (show dialog before run)

**What to build:**
When user clicks Run, show a dialog that:
1. Lists all Input nodes in the workflow
2. Provides a textarea for each input node
3. Has Cancel and Run buttons
4. On Run, passes inputs map to `runWorkflow()`

```tsx
type RunDialogProps = {
  inputNodes: Array<{id: string, label: string}>
  onRun: (inputs: Record<string, string>) => void
  onCancel: () => void
}
```

**Step 1:** Create RunDialog → **Step 2:** Wire into App.tsx → **Step 3:** Verify with `npx tsc -b` → **Step 4:** Commit

---

### Task 7: Integration Test — Full Build & Docker Rebuild

**Files:**
- Modify: `cmd/upal/main.go` (final wiring with node executors)

**What to build:**
Wire the node executors into main.go so the server can actually execute workflows:

```go
func serve() {
    cfg, _ := config.LoadDefault()

    eventBus := engine.NewEventBus()
    sessions := engine.NewSessionManager()

    // Set up provider registry from config
    providerReg := provider.NewRegistry()
    for name, pc := range cfg.Providers {
        p := provider.NewOpenAIProvider(name, pc.URL, pc.APIKey)
        providerReg.Register(p)
    }

    toolReg := tools.NewRegistry()
    runner := engine.NewRunner(eventBus, sessions)

    // Node executors
    executors := map[engine.NodeType]engine.NodeExecutorInterface{
        engine.NodeTypeInput:  &nodes.InputNode{},
        engine.NodeTypeAgent:  nodes.NewAgentNode(providerReg, toolReg, eventBus),
        engine.NodeTypeTool:   &nodes.ToolNode{Tools: toolReg},
        engine.NodeTypeOutput: &nodes.OutputNode{},
    }

    srv := api.NewServer(eventBus, sessions, runner, providerReg, toolReg, executors)
    addr := fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port)
    // ...
}
```

**Verify:**
1. `go test ./... -v -race` — all tests pass
2. `cd web && npx tsc -b` — no TypeScript errors
3. `make build` — builds successfully
4. `docker compose up -d --build` — containers start
5. Open http://localhost:8080 — UI loads
6. Add nodes, connect them, click Run — dialog appears

**Step 1:** Wire main.go → **Step 2:** Run all verifications → **Step 3:** Commit → **Step 4:** Push
