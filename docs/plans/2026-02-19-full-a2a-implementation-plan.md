# Full A2A Protocol Integration — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Convert all Upal nodes to A2A servers and the DAG runner to an A2A client, with HTTP JSON-RPC communication and Artifact-based data passing.

**Architecture:** Each node becomes an A2A JSON-RPC server registered at `/a2a/nodes/{node_id}`. The DAG runner acts as an A2A client, sending `a2a.sendMessage` requests over HTTP. Node outputs are A2A Artifacts with typed Parts (text, data, file). Agent Cards describe each node's capabilities.

**Tech Stack:** Go 1.23, Chi router, JSON-RPC 2.0, A2A protocol spec, `net/http/httptest` for testing.

---

### Task 1: A2A Core Types — Part and Artifact

**Files:**
- Create: `internal/a2a/types.go`
- Create: `internal/a2a/types_test.go`

**Step 1: Write the failing test**

```go
// internal/a2a/types_test.go
package a2a

import (
	"encoding/json"
	"testing"
)

func TestPart_TextJSON(t *testing.T) {
	p := TextPart("hello world")
	data, err := json.Marshal(p)
	if err != nil {
		t.Fatal(err)
	}
	var got Part
	if err := json.Unmarshal(data, &got); err != nil {
		t.Fatal(err)
	}
	if got.Type != "text" || got.Text != "hello world" {
		t.Errorf("got %+v", got)
	}
}

func TestPart_DataJSON(t *testing.T) {
	p := DataPart(map[string]any{"key": "value"}, "application/json")
	data, err := json.Marshal(p)
	if err != nil {
		t.Fatal(err)
	}
	var got Part
	if err := json.Unmarshal(data, &got); err != nil {
		t.Fatal(err)
	}
	if got.Type != "data" || got.MimeType != "application/json" {
		t.Errorf("got %+v", got)
	}
}

func TestArtifact_JSON(t *testing.T) {
	a := Artifact{
		Name:  "result",
		Parts: []Part{TextPart("output text")},
		Index: 0,
	}
	data, err := json.Marshal(a)
	if err != nil {
		t.Fatal(err)
	}
	var got Artifact
	if err := json.Unmarshal(data, &got); err != nil {
		t.Fatal(err)
	}
	if got.Name != "result" || len(got.Parts) != 1 || got.Parts[0].Text != "output text" {
		t.Errorf("got %+v", got)
	}
}

func TestArtifact_FirstText(t *testing.T) {
	a := Artifact{
		Parts: []Part{
			DataPart(map[string]any{"x": 1}, "application/json"),
			TextPart("the text"),
		},
	}
	if got := a.FirstText(); got != "the text" {
		t.Errorf("FirstText: got %q, want %q", got, "the text")
	}
}

func TestArtifact_FirstText_Empty(t *testing.T) {
	a := Artifact{Parts: []Part{DataPart(nil, "application/json")}}
	if got := a.FirstText(); got != "" {
		t.Errorf("FirstText: got %q, want empty", got)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/a2a/... -v -race -run TestPart`
Expected: FAIL — package does not exist

**Step 3: Write minimal implementation**

```go
// internal/a2a/types.go
package a2a

import "encoding/json"

// Part represents a piece of content in a message or artifact.
type Part struct {
	Type     string `json:"type"`               // "text", "file", "data"
	Text     string `json:"text,omitempty"`
	MimeType string `json:"mimeType,omitempty"`
	Data     any    `json:"data,omitempty"`
}

// TextPart creates a text part.
func TextPart(text string) Part {
	return Part{Type: "text", Text: text, MimeType: "text/plain"}
}

// DataPart creates a structured data part.
func DataPart(data any, mimeType string) Part {
	return Part{Type: "data", Data: data, MimeType: mimeType}
}

// Artifact is an output generated by an agent as a result of a task.
type Artifact struct {
	Name        string            `json:"name,omitempty"`
	Description string            `json:"description,omitempty"`
	Parts       []Part            `json:"parts"`
	Index       int               `json:"index"`
	Metadata    map[string]string `json:"metadata,omitempty"`
}

// FirstText returns the text content of the first text part, or "".
func (a Artifact) FirstText() string {
	for _, p := range a.Parts {
		if p.Type == "text" {
			return p.Text
		}
	}
	return ""
}

// FirstData returns the data of the first data part as JSON bytes, or nil.
func (a Artifact) FirstData() json.RawMessage {
	for _, p := range a.Parts {
		if p.Type == "data" {
			b, err := json.Marshal(p.Data)
			if err != nil {
				return nil
			}
			return b
		}
	}
	return nil
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/a2a/... -v -race`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/a2a/types.go internal/a2a/types_test.go
git commit -m "feat(a2a): add core Part and Artifact types with constructors"
```

---

### Task 2: A2A Core Types — Task, Message, TaskState

**Files:**
- Modify: `internal/a2a/types.go`
- Modify: `internal/a2a/types_test.go`

**Step 1: Write the failing test**

Add to `internal/a2a/types_test.go`:

```go
func TestTaskState_Lifecycle(t *testing.T) {
	task := NewTask("ctx-1")
	if task.Status != TaskCreated {
		t.Errorf("initial status: got %q, want %q", task.Status, TaskCreated)
	}
	if task.ID == "" {
		t.Error("task ID should not be empty")
	}
	if task.ContextID != "ctx-1" {
		t.Errorf("contextID: got %q, want %q", task.ContextID, "ctx-1")
	}
}

func TestTask_JSON(t *testing.T) {
	task := NewTask("ctx-1")
	task.Status = TaskCompleted
	task.Artifacts = []Artifact{{Parts: []Part{TextPart("done")}, Index: 0}}

	data, err := json.Marshal(task)
	if err != nil {
		t.Fatal(err)
	}
	var got Task
	if err := json.Unmarshal(data, &got); err != nil {
		t.Fatal(err)
	}
	if got.Status != TaskCompleted {
		t.Errorf("status: got %q", got.Status)
	}
	if len(got.Artifacts) != 1 {
		t.Errorf("artifacts: got %d", len(got.Artifacts))
	}
}

func TestMessage_JSON(t *testing.T) {
	msg := Message{Role: "user", Parts: []Part{TextPart("hello")}}
	data, err := json.Marshal(msg)
	if err != nil {
		t.Fatal(err)
	}
	var got Message
	if err := json.Unmarshal(data, &got); err != nil {
		t.Fatal(err)
	}
	if got.Role != "user" || len(got.Parts) != 1 {
		t.Errorf("got %+v", got)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/a2a/... -v -race -run "TestTask|TestMessage"`
Expected: FAIL — `NewTask`, `Task`, `Message`, `TaskCreated`, `TaskCompleted` undefined

**Step 3: Write minimal implementation**

Add to `internal/a2a/types.go`:

```go
import (
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
)

// TaskState represents the lifecycle state of an A2A task.
type TaskState string

const (
	TaskCreated       TaskState = "created"
	TaskWorking       TaskState = "working"
	TaskInputRequired TaskState = "input-required"
	TaskCompleted     TaskState = "completed"
	TaskFailed        TaskState = "failed"
	TaskCanceled      TaskState = "canceled"
)

// Task is the fundamental unit of work in A2A.
type Task struct {
	ID        string     `json:"id"`
	ContextID string     `json:"contextId,omitempty"`
	Status    TaskState  `json:"status"`
	Messages  []Message  `json:"messages,omitempty"`
	Artifacts []Artifact `json:"artifacts,omitempty"`
}

// Message is a communication turn between client and agent.
type Message struct {
	Role  string `json:"role"` // "user" or "agent"
	Parts []Part `json:"parts"`
}

// NewTask creates a new task with a unique ID and "created" status.
func NewTask(contextID string) *Task {
	return &Task{
		ID:        generateID("task"),
		ContextID: contextID,
		Status:    TaskCreated,
	}
}

func generateID(prefix string) string {
	b := make([]byte, 8)
	rand.Read(b)
	return prefix + "-" + hex.EncodeToString(b)
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/a2a/... -v -race`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/a2a/types.go internal/a2a/types_test.go
git commit -m "feat(a2a): add Task, Message, and TaskState types"
```

---

### Task 3: A2A Core Types — AgentCard and Skill

**Files:**
- Modify: `internal/a2a/types.go`
- Modify: `internal/a2a/types_test.go`

**Step 1: Write the failing test**

Add to `internal/a2a/types_test.go`:

```go
func TestAgentCard_JSON(t *testing.T) {
	card := AgentCard{
		Name:        "research-agent",
		Description: "Researches topics",
		URL:         "http://localhost:8080/a2a/nodes/research",
		Capabilities: Capabilities{
			Streaming:         true,
			PushNotifications: false,
		},
		Skills: []Skill{{
			ID:          "research",
			Name:        "Research Topic",
			Description: "Researches a given topic",
			InputModes:  []string{"text/plain"},
			OutputModes: []string{"text/plain", "application/json"},
		}},
		DefaultInputModes:  []string{"text/plain"},
		DefaultOutputModes: []string{"text/plain"},
	}
	data, err := json.Marshal(card)
	if err != nil {
		t.Fatal(err)
	}
	var got AgentCard
	if err := json.Unmarshal(data, &got); err != nil {
		t.Fatal(err)
	}
	if got.Name != "research-agent" {
		t.Errorf("name: got %q", got.Name)
	}
	if !got.Capabilities.Streaming {
		t.Error("streaming should be true")
	}
	if len(got.Skills) != 1 || got.Skills[0].ID != "research" {
		t.Errorf("skills: got %+v", got.Skills)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/a2a/... -v -race -run TestAgentCard`
Expected: FAIL — `AgentCard`, `Capabilities`, `Skill` undefined

**Step 3: Write minimal implementation**

Add to `internal/a2a/types.go`:

```go
// AgentCard describes an A2A agent's identity and capabilities.
type AgentCard struct {
	Name               string       `json:"name"`
	Description        string       `json:"description"`
	URL                string       `json:"url"`
	Capabilities       Capabilities `json:"capabilities"`
	Skills             []Skill      `json:"skills"`
	DefaultInputModes  []string     `json:"defaultInputModes"`
	DefaultOutputModes []string     `json:"defaultOutputModes"`
}

// Capabilities describes what the agent supports.
type Capabilities struct {
	Streaming         bool `json:"streaming"`
	PushNotifications bool `json:"pushNotifications"`
}

// Skill describes a specific capability of the agent.
type Skill struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Description string   `json:"description"`
	InputModes  []string `json:"inputModes"`
	OutputModes []string `json:"outputModes"`
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/a2a/... -v -race`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/a2a/types.go internal/a2a/types_test.go
git commit -m "feat(a2a): add AgentCard, Capabilities, and Skill types"
```

---

### Task 4: A2A Core Types — JSON-RPC Request/Response

**Files:**
- Modify: `internal/a2a/types.go`
- Modify: `internal/a2a/types_test.go`

**Step 1: Write the failing test**

Add to `internal/a2a/types_test.go`:

```go
func TestJSONRPCRequest_SendMessage(t *testing.T) {
	req := JSONRPCRequest{
		JSONRPC: "2.0",
		ID:      1,
		Method:  "a2a.sendMessage",
		Params: SendMessageParams{
			Message: Message{
				Role:  "user",
				Parts: []Part{TextPart("hello")},
			},
			Configuration: &SendMessageConfig{
				AcceptedOutputModes: []string{"text/plain"},
			},
		},
	}
	data, err := json.Marshal(req)
	if err != nil {
		t.Fatal(err)
	}
	var got JSONRPCRequest
	if err := json.Unmarshal(data, &got); err != nil {
		t.Fatal(err)
	}
	if got.Method != "a2a.sendMessage" {
		t.Errorf("method: got %q", got.Method)
	}
}

func TestJSONRPCResponse_Success(t *testing.T) {
	task := NewTask("ctx-1")
	task.Status = TaskCompleted
	resp := JSONRPCResponse{
		JSONRPC: "2.0",
		ID:      1,
		Result:  task,
	}
	data, err := json.Marshal(resp)
	if err != nil {
		t.Fatal(err)
	}
	var got JSONRPCResponse
	if err := json.Unmarshal(data, &got); err != nil {
		t.Fatal(err)
	}
	if got.Error != nil {
		t.Errorf("unexpected error: %+v", got.Error)
	}
}

func TestJSONRPCResponse_Error(t *testing.T) {
	resp := JSONRPCResponse{
		JSONRPC: "2.0",
		ID:      1,
		Error: &JSONRPCError{
			Code:    -32600,
			Message: "Invalid request",
		},
	}
	data, err := json.Marshal(resp)
	if err != nil {
		t.Fatal(err)
	}
	var got JSONRPCResponse
	if err := json.Unmarshal(data, &got); err != nil {
		t.Fatal(err)
	}
	if got.Error == nil || got.Error.Code != -32600 {
		t.Errorf("error: got %+v", got.Error)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/a2a/... -v -race -run "TestJSONRPC"`
Expected: FAIL — `JSONRPCRequest`, `JSONRPCResponse`, etc. undefined

**Step 3: Write minimal implementation**

Add to `internal/a2a/types.go`:

```go
// JSONRPCRequest is a JSON-RPC 2.0 request.
type JSONRPCRequest struct {
	JSONRPC string `json:"jsonrpc"`
	ID      any    `json:"id"`
	Method  string `json:"method"`
	Params  any    `json:"params"`
}

// JSONRPCResponse is a JSON-RPC 2.0 response.
type JSONRPCResponse struct {
	JSONRPC string        `json:"jsonrpc"`
	ID      any           `json:"id"`
	Result  any           `json:"result,omitempty"`
	Error   *JSONRPCError `json:"error,omitempty"`
}

// JSONRPCError is a JSON-RPC 2.0 error object.
type JSONRPCError struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
	Data    any    `json:"data,omitempty"`
}

// SendMessageParams is the params for a2a.sendMessage.
type SendMessageParams struct {
	Message       Message            `json:"message"`
	Configuration *SendMessageConfig `json:"configuration,omitempty"`
}

// SendMessageConfig configures a sendMessage request.
type SendMessageConfig struct {
	AcceptedOutputModes []string `json:"acceptedOutputModes,omitempty"`
	Blocking            bool     `json:"blocking,omitempty"`
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/a2a/... -v -race`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/a2a/types.go internal/a2a/types_test.go
git commit -m "feat(a2a): add JSON-RPC request/response and SendMessage types"
```

---

### Task 5: A2A Server — NodeHandler

**Files:**
- Create: `internal/a2a/server.go`
- Create: `internal/a2a/server_test.go`

**Context:** The A2A server wraps any `NodeExecutorInterface` as a JSON-RPC handler. It receives `a2a.sendMessage`, executes the node, and returns a `Task` with `Artifact`s. The `NodeExecutorInterface` from `internal/engine/types.go:83-84` is `Execute(ctx, def, state) (any, error)`.

**Step 1: Write the failing test**

```go
// internal/a2a/server_test.go
package a2a

import (
	"bytes"
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/soochol/upal/internal/engine"
)

type mockExecutor struct {
	result any
	err    error
}

func (m *mockExecutor) Execute(ctx context.Context, def *engine.NodeDefinition, state map[string]any) (any, error) {
	return m.result, m.err
}

func TestNodeHandler_SendMessage(t *testing.T) {
	executor := &mockExecutor{result: "hello from agent"}
	nodeDef := &engine.NodeDefinition{ID: "agent1", Type: engine.NodeTypeAgent}
	handler := NewNodeHandler(executor, nodeDef)

	reqBody := JSONRPCRequest{
		JSONRPC: "2.0",
		ID:      1,
		Method:  "a2a.sendMessage",
		Params: SendMessageParams{
			Message: Message{
				Role:  "user",
				Parts: []Part{TextPart("what is AI?")},
			},
		},
	}
	body, _ := json.Marshal(reqBody)
	req := httptest.NewRequest("POST", "/a2a/nodes/agent1", bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()

	handler.ServeHTTP(w, req)

	if w.Code != http.StatusOK {
		t.Fatalf("status: got %d, want 200, body: %s", w.Code, w.Body.String())
	}

	var resp JSONRPCResponse
	if err := json.Unmarshal(w.Body.Bytes(), &resp); err != nil {
		t.Fatal(err)
	}
	if resp.Error != nil {
		t.Fatalf("unexpected error: %+v", resp.Error)
	}

	// Result should be a Task
	taskData, _ := json.Marshal(resp.Result)
	var task Task
	if err := json.Unmarshal(taskData, &task); err != nil {
		t.Fatal(err)
	}
	if task.Status != TaskCompleted {
		t.Errorf("task status: got %q, want %q", task.Status, TaskCompleted)
	}
	if len(task.Artifacts) != 1 {
		t.Fatalf("artifacts: got %d, want 1", len(task.Artifacts))
	}
	if task.Artifacts[0].FirstText() != "hello from agent" {
		t.Errorf("artifact text: got %q", task.Artifacts[0].FirstText())
	}
}

func TestNodeHandler_SendMessage_ExecutorError(t *testing.T) {
	executor := &mockExecutor{err: fmt.Errorf("model timeout")}
	nodeDef := &engine.NodeDefinition{ID: "agent1", Type: engine.NodeTypeAgent}
	handler := NewNodeHandler(executor, nodeDef)

	reqBody := JSONRPCRequest{
		JSONRPC: "2.0",
		ID:      1,
		Method:  "a2a.sendMessage",
		Params: SendMessageParams{
			Message: Message{Role: "user", Parts: []Part{TextPart("hello")}},
		},
	}
	body, _ := json.Marshal(reqBody)
	req := httptest.NewRequest("POST", "/a2a/nodes/agent1", bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()

	handler.ServeHTTP(w, req)

	var resp JSONRPCResponse
	json.Unmarshal(w.Body.Bytes(), &resp)

	// Result should be a failed Task
	taskData, _ := json.Marshal(resp.Result)
	var task Task
	json.Unmarshal(taskData, &task)
	if task.Status != TaskFailed {
		t.Errorf("task status: got %q, want %q", task.Status, TaskFailed)
	}
}

func TestNodeHandler_UnknownMethod(t *testing.T) {
	handler := NewNodeHandler(&mockExecutor{result: "ok"}, &engine.NodeDefinition{ID: "a"})
	reqBody := JSONRPCRequest{JSONRPC: "2.0", ID: 1, Method: "unknown.method"}
	body, _ := json.Marshal(reqBody)
	req := httptest.NewRequest("POST", "/", bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()

	handler.ServeHTTP(w, req)

	var resp JSONRPCResponse
	json.Unmarshal(w.Body.Bytes(), &resp)
	if resp.Error == nil || resp.Error.Code != -32601 {
		t.Errorf("expected method not found error, got %+v", resp.Error)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/a2a/... -v -race -run TestNodeHandler`
Expected: FAIL — `NewNodeHandler` undefined

**Step 3: Write minimal implementation**

```go
// internal/a2a/server.go
package a2a

import (
	"encoding/json"
	"net/http"

	"github.com/soochol/upal/internal/engine"
)

// NodeHandler serves A2A JSON-RPC requests for a single node.
type NodeHandler struct {
	executor engine.NodeExecutorInterface
	nodeDef  *engine.NodeDefinition
	state    map[string]any // injected per-request by the runner
}

// NewNodeHandler creates a handler that wraps a node executor.
func NewNodeHandler(executor engine.NodeExecutorInterface, nodeDef *engine.NodeDefinition) *NodeHandler {
	return &NodeHandler{executor: executor, nodeDef: nodeDef}
}

// SetState sets the state snapshot for the next execution.
func (h *NodeHandler) SetState(state map[string]any) {
	h.state = state
}

func (h *NodeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	var req JSONRPCRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeJSONRPCError(w, nil, -32700, "Parse error")
		return
	}

	switch req.Method {
	case "a2a.sendMessage":
		h.handleSendMessage(w, r, &req)
	default:
		writeJSONRPCError(w, req.ID, -32601, "Method not found")
	}
}

func (h *NodeHandler) handleSendMessage(w http.ResponseWriter, r *http.Request, req *JSONRPCRequest) {
	// Parse params
	paramsData, err := json.Marshal(req.Params)
	if err != nil {
		writeJSONRPCError(w, req.ID, -32602, "Invalid params")
		return
	}
	var params SendMessageParams
	if err := json.Unmarshal(paramsData, &params); err != nil {
		writeJSONRPCError(w, req.ID, -32602, "Invalid params")
		return
	}

	// Build state from message parts (inject user text into state for template resolution)
	state := make(map[string]any)
	if h.state != nil {
		for k, v := range h.state {
			state[k] = v
		}
	}
	// Add the incoming message text as user input for this node
	for _, part := range params.Message.Parts {
		if part.Type == "text" {
			state["__user_input__"+h.nodeDef.ID] = part.Text
			state["__a2a_message__"] = part.Text
			break
		}
	}

	task := NewTask("")
	task.Status = TaskWorking
	task.Messages = append(task.Messages, params.Message)

	result, err := h.executor.Execute(r.Context(), h.nodeDef, state)
	if err != nil {
		task.Status = TaskFailed
		task.Messages = append(task.Messages, Message{
			Role:  "agent",
			Parts: []Part{TextPart("Error: " + err.Error())},
		})
		writeJSONRPCResponse(w, req.ID, task)
		return
	}

	artifact := resultToArtifact(result)
	task.Artifacts = []Artifact{artifact}
	task.Status = TaskCompleted
	task.Messages = append(task.Messages, Message{
		Role:  "agent",
		Parts: artifact.Parts,
	})

	writeJSONRPCResponse(w, req.ID, task)
}

// resultToArtifact converts a node executor result to an A2A Artifact.
func resultToArtifact(result any) Artifact {
	switch v := result.(type) {
	case string:
		return Artifact{Parts: []Part{TextPart(v)}, Index: 0}
	case map[string]any:
		return Artifact{Parts: []Part{DataPart(v, "application/json")}, Index: 0}
	case []any:
		return Artifact{Parts: []Part{DataPart(v, "application/json")}, Index: 0}
	default:
		return Artifact{Parts: []Part{TextPart(fmt.Sprintf("%v", v))}, Index: 0}
	}
}

func writeJSONRPCResponse(w http.ResponseWriter, id any, result any) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(JSONRPCResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result:  result,
	})
}

func writeJSONRPCError(w http.ResponseWriter, id any, code int, message string) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(JSONRPCResponse{
		JSONRPC: "2.0",
		ID:      id,
		Error:   &JSONRPCError{Code: code, Message: message},
	})
}
```

Note: Add `"fmt"` to the import block in `server.go`.

**Step 4: Run test to verify it passes**

Run: `go test ./internal/a2a/... -v -race`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/a2a/server.go internal/a2a/server_test.go
git commit -m "feat(a2a): add NodeHandler JSON-RPC server for node execution"
```

---

### Task 6: A2A Client — SendMessage over HTTP

**Files:**
- Create: `internal/a2a/client.go`
- Create: `internal/a2a/client_test.go`

**Context:** The A2A client sends `a2a.sendMessage` to a node's HTTP endpoint and returns the `Task` result. Used by the DAG runner.

**Step 1: Write the failing test**

```go
// internal/a2a/client_test.go
package a2a

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/soochol/upal/internal/engine"
)

func TestClient_SendMessage(t *testing.T) {
	// Set up a mock A2A server
	executor := &mockExecutor{result: "agent response"}
	nodeDef := &engine.NodeDefinition{ID: "agent1", Type: engine.NodeTypeAgent}
	handler := NewNodeHandler(executor, nodeDef)
	server := httptest.NewServer(handler)
	defer server.Close()

	client := NewClient(http.DefaultClient)
	task, err := client.SendMessage(context.Background(), server.URL, Message{
		Role:  "user",
		Parts: []Part{TextPart("hello")},
	})
	if err != nil {
		t.Fatal(err)
	}
	if task.Status != TaskCompleted {
		t.Errorf("status: got %q, want %q", task.Status, TaskCompleted)
	}
	if len(task.Artifacts) != 1 {
		t.Fatalf("artifacts: got %d", len(task.Artifacts))
	}
	if task.Artifacts[0].FirstText() != "agent response" {
		t.Errorf("text: got %q", task.Artifacts[0].FirstText())
	}
}

func TestClient_SendMessage_ServerError(t *testing.T) {
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		json.NewEncoder(w).Encode(JSONRPCResponse{
			JSONRPC: "2.0",
			ID:      1,
			Error:   &JSONRPCError{Code: -32000, Message: "internal error"},
		})
	}))
	defer server.Close()

	client := NewClient(http.DefaultClient)
	_, err := client.SendMessage(context.Background(), server.URL, Message{
		Role:  "user",
		Parts: []Part{TextPart("hello")},
	})
	if err == nil {
		t.Fatal("expected error")
	}
}

func TestClient_SendMessage_NetworkError(t *testing.T) {
	client := NewClient(http.DefaultClient)
	_, err := client.SendMessage(context.Background(), "http://localhost:1", Message{
		Role:  "user",
		Parts: []Part{TextPart("hello")},
	})
	if err == nil {
		t.Fatal("expected error for unreachable server")
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/a2a/... -v -race -run TestClient`
Expected: FAIL — `NewClient`, `Client` undefined

**Step 3: Write minimal implementation**

```go
// internal/a2a/client.go
package a2a

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"sync/atomic"
)

// Client sends A2A JSON-RPC requests to agent endpoints.
type Client struct {
	httpClient *http.Client
	nextID     atomic.Int64
}

// NewClient creates a new A2A client.
func NewClient(httpClient *http.Client) *Client {
	return &Client{httpClient: httpClient}
}

// SendMessage sends a2a.sendMessage to the given URL and returns the resulting Task.
func (c *Client) SendMessage(ctx context.Context, url string, msg Message) (*Task, error) {
	reqBody := JSONRPCRequest{
		JSONRPC: "2.0",
		ID:      c.nextID.Add(1),
		Method:  "a2a.sendMessage",
		Params: SendMessageParams{
			Message: msg,
			Configuration: &SendMessageConfig{
				AcceptedOutputModes: []string{"text/plain", "application/json"},
				Blocking:            true,
			},
		},
	}
	body, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("marshal request: %w", err)
	}

	httpReq, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	httpReq.Header.Set("Content-Type", "application/json")

	resp, err := c.httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("send request: %w", err)
	}
	defer resp.Body.Close()

	var rpcResp JSONRPCResponse
	if err := json.NewDecoder(resp.Body).Decode(&rpcResp); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}
	if rpcResp.Error != nil {
		return nil, fmt.Errorf("a2a error %d: %s", rpcResp.Error.Code, rpcResp.Error.Message)
	}

	// Parse result as Task
	resultData, err := json.Marshal(rpcResp.Result)
	if err != nil {
		return nil, fmt.Errorf("marshal result: %w", err)
	}
	var task Task
	if err := json.Unmarshal(resultData, &task); err != nil {
		return nil, fmt.Errorf("unmarshal task: %w", err)
	}
	return &task, nil
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/a2a/... -v -race`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/a2a/client.go internal/a2a/client_test.go
git commit -m "feat(a2a): add A2A client with SendMessage support"
```

---

### Task 7: A2A Server — Agent Card Endpoint

**Files:**
- Modify: `internal/a2a/server.go`
- Modify: `internal/a2a/server_test.go`

**Context:** Each node needs a GET endpoint returning its Agent Card. Also need a function to auto-generate an AgentCard from a `NodeDefinition`.

**Step 1: Write the failing test**

Add to `internal/a2a/server_test.go`:

```go
func TestAgentCardFromNodeDef(t *testing.T) {
	def := &engine.NodeDefinition{
		ID:   "research",
		Type: engine.NodeTypeAgent,
		Config: map[string]any{
			"model":         "anthropic/claude-sonnet-4-20250514",
			"system_prompt": "You are an expert researcher",
		},
	}
	card := AgentCardFromNodeDef(def, "http://localhost:8080")
	if card.Name != "research" {
		t.Errorf("name: got %q", card.Name)
	}
	if card.URL != "http://localhost:8080/a2a/nodes/research" {
		t.Errorf("url: got %q", card.URL)
	}
	if len(card.Skills) != 1 {
		t.Fatalf("skills: got %d", len(card.Skills))
	}
}

func TestAgentCardHandler(t *testing.T) {
	def := &engine.NodeDefinition{ID: "agent1", Type: engine.NodeTypeAgent}
	handler := NewAgentCardHandler(def, "http://localhost:8080")

	req := httptest.NewRequest("GET", "/a2a/nodes/agent1/agent-card", nil)
	w := httptest.NewRecorder()
	handler.ServeHTTP(w, req)

	if w.Code != http.StatusOK {
		t.Fatalf("status: got %d", w.Code)
	}
	var card AgentCard
	if err := json.Unmarshal(w.Body.Bytes(), &card); err != nil {
		t.Fatal(err)
	}
	if card.Name != "agent1" {
		t.Errorf("name: got %q", card.Name)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/a2a/... -v -race -run "TestAgentCard"`
Expected: FAIL — `AgentCardFromNodeDef`, `NewAgentCardHandler` undefined

**Step 3: Write minimal implementation**

Add to `internal/a2a/server.go`:

```go
// AgentCardFromNodeDef generates an AgentCard from a node definition.
func AgentCardFromNodeDef(def *engine.NodeDefinition, baseURL string) AgentCard {
	description := fmt.Sprintf("Upal %s node: %s", def.Type, def.ID)
	if sp, ok := def.Config["system_prompt"].(string); ok && sp != "" {
		description = sp
	}
	return AgentCard{
		Name:        def.ID,
		Description: description,
		URL:         fmt.Sprintf("%s/a2a/nodes/%s", baseURL, def.ID),
		Capabilities: Capabilities{
			Streaming:         false,
			PushNotifications: false,
		},
		Skills: []Skill{{
			ID:          def.ID,
			Name:        string(def.Type) + ": " + def.ID,
			Description: description,
			InputModes:  []string{"text/plain"},
			OutputModes: []string{"text/plain", "application/json"},
		}},
		DefaultInputModes:  []string{"text/plain"},
		DefaultOutputModes: []string{"text/plain"},
	}
}

// AgentCardHandler serves the Agent Card for a node via GET.
type AgentCardHandler struct {
	card AgentCard
}

// NewAgentCardHandler creates a handler that returns the agent card.
func NewAgentCardHandler(def *engine.NodeDefinition, baseURL string) *AgentCardHandler {
	return &AgentCardHandler{card: AgentCardFromNodeDef(def, baseURL)}
}

func (h *AgentCardHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(h.card)
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/a2a/... -v -race`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/a2a/server.go internal/a2a/server_test.go
git commit -m "feat(a2a): add AgentCard generation and HTTP handler"
```

---

### Task 8: A2A Template Resolution — Artifact-Based

**Files:**
- Create: `internal/a2a/template.go`
- Create: `internal/a2a/template_test.go`

**Context:** Replace the current `resolveTemplate` in `internal/nodes/agent.go:109-126` with a new version that resolves `{{node_id}}` from Artifact-based state. The state map changes from `map[string]any` to a map where values are `[]Artifact`.

**Step 1: Write the failing test**

```go
// internal/a2a/template_test.go
package a2a

import "testing"

func TestResolveTemplate_TextArtifact(t *testing.T) {
	artifacts := map[string][]Artifact{
		"research": {{Parts: []Part{TextPart("AI is transformative")}, Index: 0}},
	}
	result := ResolveTemplate("Based on: {{research}}", artifacts)
	if result != "Based on: AI is transformative" {
		t.Errorf("got %q", result)
	}
}

func TestResolveTemplate_DataArtifact(t *testing.T) {
	artifacts := map[string][]Artifact{
		"research": {{Parts: []Part{DataPart(map[string]any{"key": "val"}, "application/json")}, Index: 0}},
	}
	result := ResolveTemplate("Data: {{research.data}}", artifacts)
	if result != `Data: {"key":"val"}` {
		t.Errorf("got %q", result)
	}
}

func TestResolveTemplate_MissingNode(t *testing.T) {
	artifacts := map[string][]Artifact{}
	result := ResolveTemplate("Hello {{missing}}", artifacts)
	if result != "Hello {{missing}}" {
		t.Errorf("got %q", result)
	}
}

func TestResolveTemplate_MultipleRefs(t *testing.T) {
	artifacts := map[string][]Artifact{
		"input":  {{Parts: []Part{TextPart("topic A")}, Index: 0}},
		"output": {{Parts: []Part{TextPart("result B")}, Index: 0}},
	}
	result := ResolveTemplate("{{input}} then {{output}}", artifacts)
	if result != "topic A then result B" {
		t.Errorf("got %q", result)
	}
}

func TestResolveTemplate_NoTemplates(t *testing.T) {
	result := ResolveTemplate("no templates here", nil)
	if result != "no templates here" {
		t.Errorf("got %q", result)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/a2a/... -v -race -run TestResolveTemplate`
Expected: FAIL — `ResolveTemplate` undefined

**Step 3: Write minimal implementation**

```go
// internal/a2a/template.go
package a2a

import (
	"encoding/json"
	"regexp"
	"strings"
)

var templatePattern = regexp.MustCompile(`\{\{(\w+(?:\.\w+)*)\}\}`)

// ResolveTemplate resolves {{node_id}} references from artifact-based state.
//
// Supported patterns:
//   - {{node_id}}      → first text part of the node's first artifact
//   - {{node_id.data}} → JSON-serialized first data part
func ResolveTemplate(template string, artifacts map[string][]Artifact) string {
	return templatePattern.ReplaceAllStringFunc(template, func(match string) string {
		key := strings.Trim(match, "{}")
		parts := strings.SplitN(key, ".", 2)
		nodeID := parts[0]

		arts, ok := artifacts[nodeID]
		if !ok || len(arts) == 0 {
			return match
		}
		art := arts[0]

		if len(parts) == 2 && parts[1] == "data" {
			data := art.FirstData()
			if data == nil {
				return match
			}
			return string(data)
		}

		// Default: first text part
		text := art.FirstText()
		if text == "" {
			// Fallback: serialize the first data part
			data := art.FirstData()
			if data != nil {
				return string(data)
			}
			// Last resort: JSON of the whole artifact
			b, _ := json.Marshal(art)
			return string(b)
		}
		return text
	})
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/a2a/... -v -race`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/a2a/template.go internal/a2a/template_test.go
git commit -m "feat(a2a): add artifact-based template resolution"
```

---

### Task 9: A2A Router — Mount Node Endpoints on Chi

**Files:**
- Create: `internal/a2a/router.go`
- Create: `internal/a2a/router_test.go`

**Context:** Need a function that registers all A2A endpoints on a Chi router: per-node JSON-RPC handlers, per-node agent cards, and aggregate agent card. Uses `internal/api/server.go` Chi router pattern.

**Step 1: Write the failing test**

```go
// internal/a2a/router_test.go
package a2a

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/go-chi/chi/v5"
	"github.com/soochol/upal/internal/engine"
)

func TestRouter_AgentCardEndpoint(t *testing.T) {
	r := chi.NewRouter()
	nodes := []*engine.NodeDefinition{
		{ID: "agent1", Type: engine.NodeTypeAgent, Config: map[string]any{"model": "test/model"}},
	}
	executors := map[engine.NodeType]engine.NodeExecutorInterface{
		engine.NodeTypeAgent: &mockExecutor{result: "ok"},
	}
	MountA2ARoutes(r, nodes, executors, "http://localhost:8080")

	req := httptest.NewRequest("GET", "/a2a/nodes/agent1/agent-card", nil)
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)

	if w.Code != http.StatusOK {
		t.Fatalf("status: got %d", w.Code)
	}
	var card AgentCard
	json.Unmarshal(w.Body.Bytes(), &card)
	if card.Name != "agent1" {
		t.Errorf("name: got %q", card.Name)
	}
}

func TestRouter_AggregateAgentCard(t *testing.T) {
	r := chi.NewRouter()
	nodes := []*engine.NodeDefinition{
		{ID: "agent1", Type: engine.NodeTypeAgent},
		{ID: "agent2", Type: engine.NodeTypeAgent},
	}
	executors := map[engine.NodeType]engine.NodeExecutorInterface{
		engine.NodeTypeAgent: &mockExecutor{result: "ok"},
	}
	MountA2ARoutes(r, nodes, executors, "http://localhost:8080")

	req := httptest.NewRequest("GET", "/a2a/agent-card", nil)
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)

	if w.Code != http.StatusOK {
		t.Fatalf("status: got %d", w.Code)
	}
	var card AgentCard
	json.Unmarshal(w.Body.Bytes(), &card)
	if card.Name != "upal" {
		t.Errorf("name: got %q", card.Name)
	}
	if len(card.Skills) != 2 {
		t.Errorf("skills: got %d, want 2", len(card.Skills))
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/a2a/... -v -race -run TestRouter`
Expected: FAIL — `MountA2ARoutes` undefined

**Step 3: Write minimal implementation**

```go
// internal/a2a/router.go
package a2a

import (
	"encoding/json"
	"net/http"

	"github.com/go-chi/chi/v5"
	"github.com/soochol/upal/internal/engine"
)

// MountA2ARoutes registers all A2A endpoints on the given Chi router.
func MountA2ARoutes(r chi.Router, nodes []*engine.NodeDefinition, executors map[engine.NodeType]engine.NodeExecutorInterface, baseURL string) {
	var allSkills []Skill

	r.Route("/a2a", func(r chi.Router) {
		for _, nodeDef := range nodes {
			nodeDef := nodeDef
			executor, ok := executors[nodeDef.Type]
			if !ok {
				continue
			}

			handler := NewNodeHandler(executor, nodeDef)
			cardHandler := NewAgentCardHandler(nodeDef, baseURL)

			r.Post("/nodes/"+nodeDef.ID, handler.ServeHTTP)
			r.Get("/nodes/"+nodeDef.ID+"/agent-card", cardHandler.ServeHTTP)

			card := AgentCardFromNodeDef(nodeDef, baseURL)
			allSkills = append(allSkills, card.Skills...)
		}

		// Aggregate agent card
		aggregateCard := AgentCard{
			Name:        "upal",
			Description: "Upal visual AI workflow platform",
			URL:         baseURL + "/a2a",
			Capabilities: Capabilities{
				Streaming:         false,
				PushNotifications: false,
			},
			Skills:             allSkills,
			DefaultInputModes:  []string{"text/plain"},
			DefaultOutputModes: []string{"text/plain"},
		}
		r.Get("/agent-card", func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(aggregateCard)
		})
	})
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/a2a/... -v -race`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/a2a/router.go internal/a2a/router_test.go
git commit -m "feat(a2a): add Chi router with per-node and aggregate agent card endpoints"
```

---

### Task 10: Session State Migration — Artifact-based State

**Files:**
- Modify: `internal/engine/types.go`
- Modify: `internal/engine/session.go`
- Modify: `internal/engine/session_test.go`

**Context:** Add `Artifacts` field to `Session` alongside existing `State` for backward compatibility during migration. The `SessionManager` gets new methods for Artifact-based state.

**Step 1: Write the failing test**

Add to `internal/engine/session_test.go`:

```go
func TestSessionManager_Artifacts(t *testing.T) {
	m := NewSessionManager()
	sess := m.Create("wf1")

	// Initially no artifacts
	arts := m.GetArtifacts(sess.ID, "node1")
	if len(arts) != 0 {
		t.Errorf("expected no artifacts, got %d", len(arts))
	}

	// Set artifacts
	m.SetArtifacts(sess.ID, "node1", []any{map[string]any{"name": "result"}})
	arts = m.GetArtifacts(sess.ID, "node1")
	if len(arts) != 1 {
		t.Fatalf("expected 1 artifact, got %d", len(arts))
	}

	// Get all artifacts
	all := m.GetAllArtifacts(sess.ID)
	if len(all) != 1 {
		t.Errorf("expected 1 node in artifacts, got %d", len(all))
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/engine/... -v -race -run TestSessionManager_Artifacts`
Expected: FAIL — `GetArtifacts`, `SetArtifacts`, `GetAllArtifacts` undefined

**Step 3: Write minimal implementation**

Add to `internal/engine/types.go` — add `Artifacts` field to `Session`:

```go
type Session struct {
	ID         string                `json:"id"`
	WorkflowID string               `json:"workflow_id"`
	State      map[string]any        `json:"state"`
	Artifacts  map[string][]any      `json:"artifacts,omitempty"`
	Events     []Event               `json:"events"`
	Status     SessionStatus         `json:"status"`
	CreatedAt  time.Time             `json:"created_at"`
	UpdatedAt  time.Time             `json:"updated_at"`
}
```

Update `SessionManager.Create` in `internal/engine/session.go` to initialize `Artifacts`:

```go
func (m *SessionManager) Create(workflowID string) *Session {
	m.mu.Lock()
	defer m.mu.Unlock()
	sess := &Session{
		ID: GenerateID("sess"), WorkflowID: workflowID,
		State: make(map[string]any), Artifacts: make(map[string][]any),
		Status: SessionRunning,
		CreatedAt: time.Now(), UpdatedAt: time.Now(),
	}
	m.sessions[sess.ID] = sess
	return sess
}
```

Add new methods to `SessionManager` in `internal/engine/session.go`:

```go
func (m *SessionManager) SetArtifacts(sessionID, nodeID string, artifacts []any) {
	m.mu.Lock()
	defer m.mu.Unlock()
	if s, ok := m.sessions[sessionID]; ok {
		s.Artifacts[nodeID] = artifacts
		s.UpdatedAt = time.Now()
	}
}

func (m *SessionManager) GetArtifacts(sessionID, nodeID string) []any {
	m.mu.RLock()
	defer m.mu.RUnlock()
	s, ok := m.sessions[sessionID]
	if !ok {
		return nil
	}
	return s.Artifacts[nodeID]
}

func (m *SessionManager) GetAllArtifacts(sessionID string) map[string][]any {
	m.mu.RLock()
	defer m.mu.RUnlock()
	s, ok := m.sessions[sessionID]
	if !ok {
		return nil
	}
	cp := make(map[string][]any, len(s.Artifacts))
	for k, v := range s.Artifacts {
		cp[k] = v
	}
	return cp
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/engine/... -v -race`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/engine/types.go internal/engine/session.go internal/engine/session_test.go
git commit -m "feat(engine): add Artifact-based state to Session and SessionManager"
```

---

### Task 11: DAG Runner — A2A Client Mode

**Files:**
- Create: `internal/engine/a2a_runner.go`
- Create: `internal/engine/a2a_runner_test.go`

**Context:** New `A2ARunner` that replaces direct executor calls with HTTP A2A `SendMessage` calls. Each node has a URL derived from its ID. The runner collects Artifacts from completed tasks and passes them to downstream nodes via template resolution.

**Step 1: Write the failing test**

```go
// internal/engine/a2a_runner_test.go
package engine

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
)

func TestA2ARunner_LinearChain(t *testing.T) {
	wf := &WorkflowDefinition{
		Name: "test",
		Nodes: []NodeDefinition{
			{ID: "a", Type: NodeTypeInput},
			{ID: "b", Type: NodeTypeAgent},
			{ID: "c", Type: NodeTypeOutput},
		},
		Edges: []EdgeDefinition{{From: "a", To: "b"}, {From: "b", To: "c"}},
	}

	// Mock A2A server that echoes back node ID as result
	mux := http.NewServeMux()
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		var req map[string]any
		json.NewDecoder(r.Body).Decode(&req)
		// Extract node ID from URL path
		parts := strings.Split(r.URL.Path, "/")
		nodeID := parts[len(parts)-1]
		task := map[string]any{
			"id":        "task-1",
			"status":    "completed",
			"artifacts": []map[string]any{{
				"parts": []map[string]any{{
					"type":     "text",
					"text":     "output of " + nodeID,
					"mimeType": "text/plain",
				}},
				"index": 0,
			}},
		}
		json.NewEncoder(w).Encode(map[string]any{
			"jsonrpc": "2.0",
			"id":      req["id"],
			"result":  task,
		})
	})
	server := httptest.NewServer(mux)
	defer server.Close()

	runner := NewA2ARunner(NewEventBus(), NewSessionManager(), http.DefaultClient)
	nodeURLs := map[string]string{
		"a": server.URL + "/a2a/nodes/a",
		"b": server.URL + "/a2a/nodes/b",
		"c": server.URL + "/a2a/nodes/c",
	}
	sess, err := runner.Run(context.Background(), wf, nodeURLs, map[string]any{"a": "input data"})
	if err != nil {
		t.Fatalf("Run: %v", err)
	}
	if sess.Status != SessionCompleted {
		t.Errorf("status: got %q, want %q", sess.Status, SessionCompleted)
	}
	if len(sess.Artifacts) != 3 {
		t.Errorf("artifacts: got %d nodes, want 3", len(sess.Artifacts))
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/engine/... -v -race -run TestA2ARunner`
Expected: FAIL — `NewA2ARunner`, `A2ARunner` undefined

**Step 3: Write minimal implementation**

```go
// internal/engine/a2a_runner.go
package engine

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"sync"
	"sync/atomic"
	"time"
)

// A2ARunner executes workflows by sending A2A JSON-RPC requests to node endpoints.
type A2ARunner struct {
	eventBus   *EventBus
	sessions   *SessionManager
	httpClient *http.Client
	nextID     atomic.Int64
}

// NewA2ARunner creates a runner that communicates via A2A protocol.
func NewA2ARunner(eventBus *EventBus, sessions *SessionManager, httpClient *http.Client) *A2ARunner {
	return &A2ARunner{eventBus: eventBus, sessions: sessions, httpClient: httpClient}
}

// Run executes a workflow using A2A JSON-RPC calls to node URLs.
func (r *A2ARunner) Run(ctx context.Context, wf *WorkflowDefinition, nodeURLs map[string]string, userInputs map[string]any) (*Session, error) {
	dag, err := BuildDAG(wf)
	if err != nil {
		return nil, fmt.Errorf("build DAG: %w", err)
	}

	sess := r.sessions.Create(wf.Name)

	// Store user inputs as artifacts
	if userInputs != nil {
		for k, v := range userInputs {
			r.sessions.SetState(sess.ID, "__user_input__"+k, v)
			textVal := fmt.Sprintf("%v", v)
			r.sessions.SetArtifacts(sess.ID, "__user_input__"+k, []any{
				map[string]any{
					"parts": []map[string]any{{"type": "text", "text": textVal, "mimeType": "text/plain"}},
					"index": 0,
				},
			})
		}
	}

	r.eventBus.Publish(Event{
		ID: GenerateID("ev"), WorkflowID: wf.Name, SessionID: sess.ID,
		Type: EventNodeStarted, Payload: map[string]any{"workflow": wf.Name}, Timestamp: time.Now(),
	})

	done := make(map[string]chan struct{})
	for _, n := range wf.Nodes {
		done[n.ID] = make(chan struct{})
	}

	var wg sync.WaitGroup
	var execErr error
	var errOnce sync.Once

	for _, nodeID := range dag.TopologicalOrder() {
		nodeID := nodeID
		wg.Add(1)
		go func() {
			defer wg.Done()
			for _, parentID := range dag.Parents(nodeID) {
				select {
				case <-done[parentID]:
				case <-ctx.Done():
					return
				}
			}

			nodeURL, ok := nodeURLs[nodeID]
			if !ok {
				errOnce.Do(func() { execErr = fmt.Errorf("no URL for node %q", nodeID) })
				close(done[nodeID])
				return
			}

			r.eventBus.Publish(Event{
				ID: GenerateID("ev"), WorkflowID: wf.Name, SessionID: sess.ID,
				NodeID: nodeID, Type: EventNodeStarted, Timestamp: time.Now(),
			})

			// Build message from parent artifacts
			allArtifacts := r.sessions.GetAllArtifacts(sess.ID)
			messageText := buildMessageText(nodeID, allArtifacts, dag)
			if messageText == "" {
				messageText = fmt.Sprintf("Execute node %s", nodeID)
			}

			task, err := r.sendMessage(ctx, nodeURL, messageText)
			if err != nil {
				r.eventBus.Publish(Event{
					ID: GenerateID("ev"), WorkflowID: wf.Name, SessionID: sess.ID,
					NodeID: nodeID, Type: EventNodeError, Payload: map[string]any{"error": err.Error()}, Timestamp: time.Now(),
				})
				errOnce.Do(func() { execErr = fmt.Errorf("node %q: %w", nodeID, err) })
				close(done[nodeID])
				return
			}

			// Store artifacts
			r.sessions.SetArtifacts(sess.ID, nodeID, task["artifacts"])
			// Also store in legacy state for backward compat
			if arts, ok := task["artifacts"].([]any); ok && len(arts) > 0 {
				if art, ok := arts[0].(map[string]any); ok {
					if parts, ok := art["parts"].([]any); ok && len(parts) > 0 {
						if part, ok := parts[0].(map[string]any); ok {
							if text, ok := part["text"].(string); ok {
								r.sessions.SetState(sess.ID, nodeID, text)
							}
						}
					}
				}
			}

			r.eventBus.Publish(Event{
				ID: GenerateID("ev"), WorkflowID: wf.Name, SessionID: sess.ID,
				NodeID: nodeID, Type: EventNodeCompleted, Payload: map[string]any{"task": task}, Timestamp: time.Now(),
			})
			close(done[nodeID])
		}()
	}

	wg.Wait()

	if execErr != nil {
		r.sessions.SetStatus(sess.ID, SessionFailed)
		finalSess, _ := r.sessions.Get(sess.ID)
		return finalSess, execErr
	}
	r.sessions.SetStatus(sess.ID, SessionCompleted)
	finalSess, _ := r.sessions.Get(sess.ID)
	return finalSess, nil
}

func (r *A2ARunner) sendMessage(ctx context.Context, url, text string) (map[string]any, error) {
	reqBody := map[string]any{
		"jsonrpc": "2.0",
		"id":      r.nextID.Add(1),
		"method":  "a2a.sendMessage",
		"params": map[string]any{
			"message": map[string]any{
				"role": "user",
				"parts": []map[string]any{
					{"type": "text", "text": text, "mimeType": "text/plain"},
				},
			},
		},
	}
	body, err := json.Marshal(reqBody)
	if err != nil {
		return nil, err
	}

	httpReq, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	httpReq.Header.Set("Content-Type", "application/json")

	resp, err := r.httpClient.Do(httpReq)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var rpcResp map[string]any
	if err := json.NewDecoder(resp.Body).Decode(&rpcResp); err != nil {
		return nil, err
	}
	if rpcErr, ok := rpcResp["error"]; ok && rpcErr != nil {
		errMap, _ := rpcErr.(map[string]any)
		return nil, fmt.Errorf("a2a error: %v", errMap["message"])
	}
	result, ok := rpcResp["result"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid result type")
	}
	status, _ := result["status"].(string)
	if status == "failed" {
		return nil, fmt.Errorf("task failed")
	}
	return result, nil
}

func buildMessageText(nodeID string, allArtifacts map[string][]any, dag *DAG) string {
	parents := dag.Parents(nodeID)
	if len(parents) == 0 {
		return ""
	}
	var texts []string
	for _, parentID := range parents {
		arts, ok := allArtifacts[parentID]
		if !ok {
			// Check for user input
			arts = allArtifacts["__user_input__"+parentID]
		}
		if len(arts) == 0 {
			continue
		}
		if art, ok := arts[0].(map[string]any); ok {
			if parts, ok := art["parts"].([]any); ok {
				for _, p := range parts {
					if part, ok := p.(map[string]any); ok {
						if text, ok := part["text"].(string); ok {
							texts = append(texts, text)
						}
					}
				}
			}
		}
	}
	if len(texts) == 0 {
		return ""
	}
	result := ""
	for i, t := range texts {
		if i > 0 {
			result += "\n\n"
		}
		result += t
	}
	return result
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/engine/... -v -race`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/engine/a2a_runner.go internal/engine/a2a_runner_test.go
git commit -m "feat(engine): add A2ARunner for HTTP JSON-RPC workflow execution"
```

---

### Task 12: Wire A2A Routes into Server

**Files:**
- Modify: `internal/api/server.go:43-71` — add A2A route mounting
- Modify: `internal/api/server_test.go` — test A2A agent card endpoint

**Step 1: Write the failing test**

Add to `internal/api/server_test.go`:

```go
func TestAPI_AggregateAgentCard(t *testing.T) {
	srv := NewServer(engine.NewEventBus(), engine.NewSessionManager(), nil, map[engine.NodeType]engine.NodeExecutorInterface{
		engine.NodeTypeInput:  &mockAPIExecutor{},
		engine.NodeTypeAgent:  &mockAPIExecutor{},
		engine.NodeTypeOutput: &mockAPIExecutor{},
	})

	// Create a workflow first so nodes exist
	wf := engine.WorkflowDefinition{
		Name:    "test-wf",
		Version: 1,
		Nodes: []engine.NodeDefinition{
			{ID: "input1", Type: engine.NodeTypeInput},
			{ID: "agent1", Type: engine.NodeTypeAgent, Config: map[string]any{"model": "test/model"}},
		},
	}
	body, _ := json.Marshal(wf)
	req := httptest.NewRequest("POST", "/api/workflows", bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	srv.Handler().ServeHTTP(w, req)

	// Now check aggregate agent card
	req = httptest.NewRequest("GET", "/a2a/agent-card", nil)
	w = httptest.NewRecorder()
	srv.Handler().ServeHTTP(w, req)

	if w.Code != http.StatusOK {
		t.Fatalf("status: got %d, body: %s", w.Code, w.Body.String())
	}
}

type mockAPIExecutor struct{}

func (m *mockAPIExecutor) Execute(ctx context.Context, def *engine.NodeDefinition, state map[string]any) (any, error) {
	return "ok", nil
}
```

Note: Need to add `"context"` to the imports of server_test.go.

**Step 2: Run test to verify it fails**

Run: `go test ./internal/api/... -v -race -run TestAPI_AggregateAgentCard`
Expected: FAIL — no `/a2a/agent-card` route registered

**Step 3: Modify server.go Handler() method**

Modify `internal/api/server.go:43-71` `Handler()` to mount A2A routes:

Add import for `"github.com/soochol/upal/internal/a2a"` and modify `Handler()`:

```go
func (s *Server) Handler() http.Handler {
	r := chi.NewRouter()
	r.Use(middleware.Logger)
	r.Use(middleware.Recoverer)
	r.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE"},
		AllowedHeaders:   []string{"Content-Type"},
		AllowCredentials: true,
	}))
	r.Route("/api", func(r chi.Router) {
		r.Route("/workflows", func(r chi.Router) {
			r.Post("/", s.createWorkflow)
			r.Get("/", s.listWorkflows)
			r.Get("/{name}", s.getWorkflow)
			r.Put("/{name}", s.updateWorkflow)
			r.Delete("/{name}", s.deleteWorkflow)
			r.Post("/{name}/run", s.runWorkflow)
		})
		r.Post("/generate", s.generateWorkflow)
		r.Post("/upload", s.uploadFile)
		r.Get("/files", s.listFiles)
	})

	// Mount A2A routes — static aggregate agent card + per-workflow dynamic endpoints
	a2a.MountStaticA2ARoutes(r, s.executors, "")

	// Serve static files (frontend)
	r.Handle("/*", StaticHandler("web/dist"))

	return r
}
```

For this to work, we need to add a simpler `MountStaticA2ARoutes` function to `internal/a2a/router.go` that registers the aggregate card and a fallback for dynamic node routes:

```go
// MountStaticA2ARoutes registers the aggregate agent card and a catch-all for dynamic node endpoints.
func MountStaticA2ARoutes(r chi.Router, executors map[engine.NodeType]engine.NodeExecutorInterface, baseURL string) {
	r.Route("/a2a", func(r chi.Router) {
		r.Get("/agent-card", func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(AgentCard{
				Name:        "upal",
				Description: "Upal visual AI workflow platform",
				URL:         baseURL + "/a2a",
				Capabilities: Capabilities{
					Streaming:         false,
					PushNotifications: false,
				},
				DefaultInputModes:  []string{"text/plain"},
				DefaultOutputModes: []string{"text/plain"},
			})
		})

		// Dynamic node endpoints are registered per-workflow at runtime
		r.Post("/nodes/{nodeID}", func(w http.ResponseWriter, r *http.Request) {
			writeJSONRPCError(w, nil, -32601, "Node not registered. Start a workflow run first.")
		})
		r.Get("/nodes/{nodeID}/agent-card", func(w http.ResponseWriter, r *http.Request) {
			http.Error(w, "Node not registered", http.StatusNotFound)
		})
	})
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/api/... -v -race`
Expected: PASS (all existing tests still pass + new test passes)

**Step 5: Commit**

```bash
git add internal/api/server.go internal/api/server_test.go internal/a2a/router.go
git commit -m "feat(api): mount A2A aggregate agent card route on server"
```

---

### Task 13: Integration Test — Full A2A Workflow Execution

**Files:**
- Create: `internal/a2a/integration_test.go`

**Context:** End-to-end test: start A2A node servers, create an A2ARunner, execute a 3-node workflow (input → agent → output). Uses `httptest.Server` for the node endpoints.

**Step 1: Write the integration test**

```go
// internal/a2a/integration_test.go
package a2a

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/go-chi/chi/v5"
	"github.com/soochol/upal/internal/engine"
)

// mockAgentExecutor returns a response based on state content.
type mockAgentExecutor struct{}

func (m *mockAgentExecutor) Execute(ctx context.Context, def *engine.NodeDefinition, state map[string]any) (any, error) {
	// For input nodes: return user input
	if def.Type == engine.NodeTypeInput {
		key := "__user_input__" + def.ID
		if v, ok := state[key]; ok {
			return v, nil
		}
		return "no input", nil
	}
	// For agent nodes: return processed text
	if msg, ok := state["__a2a_message__"]; ok {
		return "Processed: " + msg.(string), nil
	}
	return "agent output", nil
}

func TestIntegration_LinearWorkflow(t *testing.T) {
	// Define workflow
	wf := &engine.WorkflowDefinition{
		Name: "test-pipeline",
		Nodes: []engine.NodeDefinition{
			{ID: "input", Type: engine.NodeTypeInput},
			{ID: "agent", Type: engine.NodeTypeAgent, Config: map[string]any{"model": "test/model"}},
			{ID: "output", Type: engine.NodeTypeOutput},
		},
		Edges: []engine.EdgeDefinition{
			{From: "input", To: "agent"},
			{From: "agent", To: "output"},
		},
	}

	// Set up A2A node servers
	executor := &mockAgentExecutor{}
	r := chi.NewRouter()
	nodeDefs := make([]*engine.NodeDefinition, len(wf.Nodes))
	for i := range wf.Nodes {
		nodeDefs[i] = &wf.Nodes[i]
	}
	executors := map[engine.NodeType]engine.NodeExecutorInterface{
		engine.NodeTypeInput:  executor,
		engine.NodeTypeAgent:  executor,
		engine.NodeTypeOutput: executor,
	}
	MountA2ARoutes(r, nodeDefs, executors, "http://localhost")
	server := httptest.NewServer(r)
	defer server.Close()

	// Create A2ARunner and execute
	eventBus := engine.NewEventBus()
	sessions := engine.NewSessionManager()
	a2aRunner := engine.NewA2ARunner(eventBus, sessions, http.DefaultClient)

	nodeURLs := map[string]string{
		"input":  server.URL + "/a2a/nodes/input",
		"agent":  server.URL + "/a2a/nodes/agent",
		"output": server.URL + "/a2a/nodes/output",
	}

	sess, err := a2aRunner.Run(context.Background(), wf, nodeURLs, map[string]any{"input": "hello world"})
	if err != nil {
		t.Fatalf("Run: %v", err)
	}
	if sess.Status != engine.SessionCompleted {
		t.Errorf("status: got %q, want %q", sess.Status, engine.SessionCompleted)
	}
	if len(sess.Artifacts) == 0 {
		t.Error("expected artifacts in session")
	}
}

func TestIntegration_ParallelWorkflow(t *testing.T) {
	wf := &engine.WorkflowDefinition{
		Name: "parallel-test",
		Nodes: []engine.NodeDefinition{
			{ID: "input", Type: engine.NodeTypeInput},
			{ID: "agent_a", Type: engine.NodeTypeAgent},
			{ID: "agent_b", Type: engine.NodeTypeAgent},
			{ID: "output", Type: engine.NodeTypeOutput},
		},
		Edges: []engine.EdgeDefinition{
			{From: "input", To: "agent_a"},
			{From: "input", To: "agent_b"},
			{From: "agent_a", To: "output"},
			{From: "agent_b", To: "output"},
		},
	}

	executor := &mockAgentExecutor{}
	r := chi.NewRouter()
	nodeDefs := make([]*engine.NodeDefinition, len(wf.Nodes))
	for i := range wf.Nodes {
		nodeDefs[i] = &wf.Nodes[i]
	}
	executors := map[engine.NodeType]engine.NodeExecutorInterface{
		engine.NodeTypeInput:  executor,
		engine.NodeTypeAgent:  executor,
		engine.NodeTypeOutput: executor,
	}
	MountA2ARoutes(r, nodeDefs, executors, "http://localhost")
	server := httptest.NewServer(r)
	defer server.Close()

	eventBus := engine.NewEventBus()
	sessions := engine.NewSessionManager()
	a2aRunner := engine.NewA2ARunner(eventBus, sessions, http.DefaultClient)

	nodeURLs := map[string]string{
		"input":   server.URL + "/a2a/nodes/input",
		"agent_a": server.URL + "/a2a/nodes/agent_a",
		"agent_b": server.URL + "/a2a/nodes/agent_b",
		"output":  server.URL + "/a2a/nodes/output",
	}

	sess, err := a2aRunner.Run(context.Background(), wf, nodeURLs, map[string]any{"input": "test input"})
	if err != nil {
		t.Fatalf("Run: %v", err)
	}
	if sess.Status != engine.SessionCompleted {
		t.Errorf("status: got %q", sess.Status)
	}
	// All 4 nodes should have artifacts
	if len(sess.Artifacts) < 3 {
		t.Errorf("expected at least 3 nodes with artifacts, got %d", len(sess.Artifacts))
	}
}

func TestIntegration_AgentCard_Discovery(t *testing.T) {
	wf := &engine.WorkflowDefinition{
		Name: "card-test",
		Nodes: []engine.NodeDefinition{
			{ID: "agent1", Type: engine.NodeTypeAgent, Config: map[string]any{"model": "test/model", "system_prompt": "You are helpful"}},
		},
	}
	r := chi.NewRouter()
	nodeDefs := []*engine.NodeDefinition{&wf.Nodes[0]}
	executors := map[engine.NodeType]engine.NodeExecutorInterface{
		engine.NodeTypeAgent: &mockAgentExecutor{},
	}
	MountA2ARoutes(r, nodeDefs, executors, "http://localhost:8080")
	server := httptest.NewServer(r)
	defer server.Close()

	// Fetch agent card
	resp, err := http.Get(server.URL + "/a2a/nodes/agent1/agent-card")
	if err != nil {
		t.Fatal(err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		t.Fatalf("status: %d", resp.StatusCode)
	}
	var card AgentCard
	json.NewDecoder(resp.Body).Decode(&card)
	if card.Name != "agent1" {
		t.Errorf("name: got %q", card.Name)
	}
	if card.Description != "You are helpful" {
		t.Errorf("description: got %q", card.Description)
	}
}
```

**Step 2: Run integration tests**

Run: `go test ./internal/a2a/... -v -race -run TestIntegration`
Expected: PASS

**Step 3: Commit**

```bash
git add internal/a2a/integration_test.go
git commit -m "test(a2a): add integration tests for linear, parallel workflows and agent card discovery"
```

---

### Task 14: Verify All Tests Pass

**Step 1: Run all existing tests**

Run: `go test ./... -v -race`
Expected: ALL PASS. No regressions in existing engine, nodes, api, or provider tests.

**Step 2: Run frontend type check**

Run: `cd web && npx tsc -b`
Expected: No type errors (frontend unchanged in this phase).

**Step 3: Commit (if any test fixes needed)**

```bash
git add -A
git commit -m "fix: resolve test issues from A2A integration"
```

---

### Task 15: Update main.go — Wire A2A Runner

**Files:**
- Modify: `cmd/upal/main.go:32-114`

**Context:** Add the A2ARunner as an alternative to the current Runner. The A2A routes need to be mounted when the server starts. Initially both runners coexist — the existing `/api/workflows/{name}/run` still uses the direct runner, but we add a new config option or endpoint for A2A mode.

**Step 1: Write the failing test**

No separate test — this is wiring. Verified by running the server and hitting `/a2a/agent-card`.

**Step 2: Modify main.go**

Add import for `a2a` package and mount routes:

```go
import (
	// ... existing imports ...
	a2apkg "github.com/soochol/upal/internal/a2a"
)

// In serve(), after creating srv:
// Mount A2A routes with all known node types
nodeDefs := []*engine.NodeDefinition{}  // populated dynamically per workflow
a2apkg.MountStaticA2ARoutes(srv.Handler().(*chi.Mux), executors, fmt.Sprintf("http://%s:%d", cfg.Server.Host, cfg.Server.Port))
```

Actually, since `srv.Handler()` returns an `http.Handler` (not chi.Mux), the A2A routes are already mounted inside `server.go` via `MountStaticA2ARoutes`. No changes needed to main.go for Phase 1.

**Step 3: Verify it compiles and serves**

Run: `go build ./cmd/upal`
Expected: Compiles without errors.

**Step 4: Commit**

```bash
git add cmd/upal/main.go
git commit -m "chore: verify main.go compiles with A2A integration"
```

---

### Task 16: Build and Smoke Test

**Step 1: Full build**

Run: `make build`
Expected: Compiles successfully, binary at `bin/upal`

**Step 2: Run all tests one final time**

Run: `make test`
Expected: ALL PASS

**Step 3: Final commit if needed, then summarize**

```bash
git log --oneline -10
```

Expected output shows all task commits in order.

---

## Summary of Files Created/Modified

| File | Action | Description |
|------|--------|-------------|
| `internal/a2a/types.go` | Create | Part, Artifact, Task, Message, AgentCard, JSON-RPC types |
| `internal/a2a/types_test.go` | Create | Unit tests for all A2A types |
| `internal/a2a/server.go` | Create | NodeHandler JSON-RPC server, AgentCard handler |
| `internal/a2a/server_test.go` | Create | Server handler tests |
| `internal/a2a/client.go` | Create | A2A HTTP client with SendMessage |
| `internal/a2a/client_test.go` | Create | Client tests with mock servers |
| `internal/a2a/template.go` | Create | Artifact-based template resolution |
| `internal/a2a/template_test.go` | Create | Template tests |
| `internal/a2a/router.go` | Create | Chi router mounting for A2A endpoints |
| `internal/a2a/router_test.go` | Create | Router integration tests |
| `internal/a2a/integration_test.go` | Create | Full workflow integration tests |
| `internal/engine/types.go` | Modify | Add `Artifacts` field to Session |
| `internal/engine/session.go` | Modify | Add artifact-aware SessionManager methods |
| `internal/engine/session_test.go` | Modify | Test artifact methods |
| `internal/engine/a2a_runner.go` | Create | A2ARunner for HTTP-based workflow execution |
| `internal/engine/a2a_runner_test.go` | Create | A2ARunner tests |
| `internal/api/server.go` | Modify | Mount A2A routes |
| `internal/api/server_test.go` | Modify | Test A2A agent card via API |
